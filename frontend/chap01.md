# 第一章 课程介绍

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [第一章 课程介绍](#第一章-课程介绍)
  - [1.1 为什么全栈技能很重要](#11-为什么全栈技能很重要)
  - [1.2 课程介绍](#12-课程介绍)
  - [1.3 课程结构](#13-课程结构)
  - [1.4 需求分析](#14-需求分析)
    - [1.4.1. 需求的来源](#141-需求的来源)
    - [1.4.2. 需求的概要](#142-需求的概要)
    - [1.4.3 需求梳理](#143-需求梳理)
    - [1.4.4 需求分解](#144-需求分解)
  - [1.5 技术选型](#15-技术选型)
  - [1.6 Flutter 简介](#16-flutter-简介)
  - [1.7 Spring Boot 简介](#17-spring-boot-简介)
    - [1.7.1 Spring Boot 3.x](#171-spring-boot-3x)
  - [1.8 容器（Docker）](#18-容器docker)
    - [1.8.1 Docker 简介](#181-docker-简介)
    - [1.8.2 Docker 架构](#182-docker-架构)
    - [1.8.3 Docker 安装](#183-docker-安装)

<!-- /code_chunk_output -->

## 1.1 为什么全栈技能很重要

全栈技能是指一个人能够同时掌握多个技能，比如前端、后端、移动端、数据库、运维等等。全栈技能的重要性在于，它可以让一个人在一个项目中同时承担多个角色，这样可以大大提高项目的开发效率。

从求职角度来说，全栈技能可以让你在求职时更加灵活，因为你可以同时应对前端、后端、移动端、数据库、运维等多个岗位的需求，这样可以大大提高求职的成功率。

从企业需求角度来说，全栈技能可以让一个人同时承担多个角色，从而大大提高项目的开发效率。企业目前越来越需要拥有全栈技能的人才。

从视野上来说，全栈技能可以让一个人更好地理解整个项目，从而更好地解决问题。你可以更好地理解前端的需求，从而更好地设计后端的接口；你可以更好地理解后端的需求，从而更好地设计前端的界面。

从个人发展角度来说，全栈技能可以让你在一个领域中更快地成长，因为不同的技术栈既有相通之处，也有不同之处，你可以从不同的技术栈中学习到不同的知识，从而更好地成长。而且当一种思想在某种框架中得到很好的体现，并得到用户的认可，你会发现其他框架也会借鉴这种思想，从而更好地发展自己。这使得一方面你在新的技术栈中会发现一些似曾相识的东西，另一方面你也可以更好地理解这些似曾相识的东西，这极大的提升了学习效率。当然，任何一个技术栈都有它的历史周期，当一个技术在开始衰落时，有全栈能力的你可以更快地转型到下一个技术栈中，从而更好地发展自己。

不同的技术栈的技能积累是不一样的，比如前端技能的积累主要是在 HTML、CSS、JavaScript、TypeScript、Vue、React、Angular 等技术栈中，后端技能的积累主要是在 Java、Python、Go、Node.js 等技术栈中，移动端技能的积累主要是在 Android、iOS、Flutter 等技术栈中，数据库技能的积累主要是在 MySQL、MongoDB、Redis 等技术栈中，运维技能的积累主要是在 Linux、Docker、Kubernetes 等技术栈中。

## 1.2 课程介绍

本课程是一个以 Flutter 为前端技术栈，Java 为后端技术栈的全栈开发课程。如果你有一定前端或移动端编程基础可能学习体验会更好。比如 HTML、CSS、JavaScript、TypeScript、Vue、React、Angular 等技术栈中的一种或多种，或者 Android、iOS、Flutter 等技术栈中的一种或多种。

课程中会应用面向对象思想和函数式编程，但不会生硬的进行概念的堆砌，，而会在实际的项目融入这些编程思想。如果你觉得对这些概念比较陌生，可以先去学习一些面向对象的编程思想和函数式编程的知识，慕课网中有我的 [《Angular 开发拼多多 WebApp－从基础到项目实战》](https://coding.imooc.com/class/336.html) 以及 [《JAVA 函数式编程》](https://www.imooc.com/learn/1284)，都是你可以参考的课程。

本课程的目标是让你掌握 Flutter、Java、MySQL、Docker 等技术栈，从而让你成为一个全栈开发工程师。本课程的内容包括：

- TODO
- TODO
- TODO

由于在不同的公司的团队中，我观察到很多新人对于软件的需求分析和设计能力都不足。而且往往由于缺乏经验和相关知识，在独立承接任务时，往往会出现一些问题，比如：

- 不知道如何进行需求分析，单纯依赖于客户的需求，导致需求不完整，或者需求不合理。
- 没有能力快速的进行原型设计，导致前期和客户的沟通成本高，而且往往会造成后期的改动非常频繁。
- 不知道怎样挖掘隐性需求，导致很多需求没有被发现。
- 不知道怎样和前端/后端沟通需要配合的需求，导致前端/后端的开发效率低。
- 没有重构的思想和能力，导致代码质量低，后期维护成本高。
- 不重视测试和验证，导致很多问题在上线后才发现，而且往往会造成很大的损失。

所以本课程采用了 **“问题-方案-原型-验证-改进”** 的开发模式，我们会先讲解一个问题，然后探讨一个方案，随之构建一个原型，接着会完成验证，然后会进行改进，之后再讲解下一个问题，如此循环。这样做的好处是大家的设计，开发，重构和测试能力都会得到提升，而且会反复强化。

## 1.3 课程结构

本课程的结构如下：

- 第一章：为什么全栈技能很重要

## 1.4 需求分析

### 1.4.1. 需求的来源

在做需求分析的时候，第一步是要确定需求的来源，也就是要确定需求是从哪里来的。这个过程往往需要和不同的人进行沟通，比如和产品经理、项目经理、UI 设计师、运营人员等进行沟通，确定需求的来源。

一般来说一个需求的提出会有一个主导方，但这个主导方往往不一定能清晰的描述自己的需求，所以我们需要和他们进行沟通，了解他们的需求，然后再进行需求分析。而且需求往往会有隐含的参与者，有时这些参与者不那么明显，我们需要通过梳理需求找到这些参与者。

在这个课程中，我们的需求是来自于运营人员，他们需要一个可视化的界面来配置首页的布局，而不是通过代码来配置。这个需求的来源是运营人员。让我们第一次接触这个需求的时候，可能认为运营人员是唯一的参与者，但是实际上，这个需求还有隐含的参与者，那就是开发人员。这个需求需要 App 的开发者的配合，他们需要获得我们的布局配置，然后根据我们的布局配置来开发 App。接下来你会发现，App 的开发者需要接口，而这个接口就是我们的后端提供的。而可视化的界面同样需要前端和后端的配合，前端需要提供界面，后端需要提供接口。所以这个需求的参与者不仅仅是运营人员，还有 App 的开发者，还有前端的开发者，还有后端的开发者。

当然还有一种参与者，并非具体的人，比如我们的用户。我们的用户是最终的使用者，他们需要一个好用的 App，而这个好用的 App，就是我们的 App。所以我们的需求不仅仅是为了满足运营人员的需求，也是为了满足用户的需求。比如公司的技术要求，如果公司要求保证首页的渲染效率，那么我们的需求就需要满足这个要求，这涉及到你要采用哪些方案来实现你的需求，比如 HTML 这时候可能就不太合适。再有需要考虑的就是国家的法律法规，比如国家的法律法规要求对用户数据需要进行加密，那么我们的需求就需要满足这个要求。

所有参与方都需要参与到需求分析的过程中，这样才能保证我们的需求是正确的，是能够满足所有参与者的需求的。

对于我们的课程来说，必须做一些必要的假定：

- **运营人员**：我们假定运营人员是一个没有技术基础的人，他可以通过可视化的界面来配置首页的布局，但是他不会编写代码。而且他也不能接受太繁琐的配置步骤，比如太多的参数需要配置，太多的步骤需要操作，这样他就会觉得很繁琐，不愿意去配置。他的首要目的是想要快速的配置出一个在指定时间内可以上线的首页，而不是想要一个在线页面编辑器。
- **首页性能**：我们假定公司对于首页性能有较高的要求，所以我们的技术选择需要考虑到这一点。

### 1.4.2. 需求的概要

在这个课程中，我们将开发一个全栈应用，这个应用有几个部分构成：

- **Flutter App**：目标平台是 Android/iOS，我们将开发一个常见的 App 首页，这个首页是由一系列组件构成，包括轮播图，一行一张的图片，一行两张的图片，一行三张的图片，一行多张的图片，一行一个商品卡片，一行两个的商品卡片以及一个商品瀑布流。区别于一般 App 的是，这个首页是动态的，它的内容是从后端获取的，而不是写死在代码中的。这个应用的主要功能是展示我们后台的布局配置，所以我们不会做的太复杂，仅做演示目的。

  ![图 1](http://ngassets.twigcodes.com/37c8d757c8dafa0559b97e60ef4e01f666ffa0df5b530bbc2a4431fb45e97247.png)

  ![图 2](http://ngassets.twigcodes.com/58fe33d8d89c92d31ea511ccacd8ae959d5b529eb55e7810bc94de576bc28cd9.png)

- **Flutter Web 前端**：目标平台是 Web，这个前端是用于给运营人员操作的，运营人员可以通过这个前端来配置首页的布局，比如添加轮播图，添加一行一张的图片，添加一行两张的图片，添加一行三张的图片，添加一行多张的图片，添加一行一个商品卡片，添加一行两个的商品卡片以及添加商品瀑布流。这个前端的主要功能是让运营人员可以通过图形化的界面来配置首页的布局，而不是通过代码来配置。本质上是一个可视化的配置平台，也可以理解成一个简单的低代码平台。
  ![图 3](http://ngassets.twigcodes.com/4f25e1c343d1ea679b7edd892c26d2dbfc26b903f38c60e102884670f449dec6.png)

  ![图 4](http://ngassets.twigcodes.com/bfdd9ee34717f6d74a327b62bf7252e3ae76fc6a0d01b5a034d4b087cd5e00a8.png)

- **Java 后端**：这个后端其实有两部分构成：

  - 一个是 App 后端接口，这个后端主要是用于给 Flutter App 提供接口，Flutter Web 前端通过这些接口来获取首页的布局配置。
  - 另一个是 Web 后台接口，这个后端主要是用于提供管理布局配置，以及更新首页的布局配置。

    ![图 5](http://ngassets.twigcodes.com/fa5b9d75d29947f6c3899bb2210539d63af869fc843d0604b9b091aab7025ed8.png)

### 1.4.3 需求梳理

一般来说，我们在国内很少会从用户处直接得到完善的需求文档，所以我们需要从运营人员那里得到需求，然后再进行需求梳理，梳理出完整的需求文档。

在做需求分析的时候，第一步是要确定需求的范围，也就是要确定我们要做什么，不要做什么。这个过程往往需要和不同的人进行沟通，比如和产品经理、项目经理、UI 设计师、运营人员等进行沟通，确定我们要做什么，不要做什么。

在这个课程中，由于我们没法直接接触真正的运营人员，或前端，后端的开发人员或产品经理等角色，所以我这里会根据我自己的个人经验，来先梳理出一个框架：

- 需求 1：运营人员可以通过可视化的界面来配置首页的布局
- 需求 2：首页的布局是有生效时间段的，比如 2020-01-01 00:00:00 到 2020-01-02 00:00:00
- 需求 3：首页的布局可以有多个，因为不同的时间段，首页的布局可能是不一样的
- 需求 4：首页的布局可以有几个状态，比如草稿、已发布、已下线
- 需求 5：相同或者重叠的时间段，只能有一个布局是已发布的，因为 App 只能展示一个布局
- 需求 6：App 获取的布局是当前时间段的已发布的布局，如果当前时间段没有布局，那么 App 获取的是最近的一个布局
  - 需要思考的是，如果当前时间段没有布局，那么 App 获取的是最近的一个布局，那么这个最近的布局是什么？是最近的已发布的布局，还是最近的任意布局？如果还是没有布局，那么 App 获取的是什么？也就是如何兜底？这其实是一个隐含的需求，需要我们思考。
- 需求 7：运营人员不能接受太繁琐的配置步骤，比如太多的参数需要配置，太多的步骤需要操作。
- 需求 8：运营人员可以创建/编辑/删除布局
- 需求 9：运营人员可以按条件查询布局
- 需求 10：运营人员可以发布/下线布局
- 需求 11：一个用于 demo 的 App，可以获取到配置的布局

### 1.4.4 需求分解

上面这些需求只是一个骨架，还需要进一步细化，比如需求 1。但在细化之前我们必须先确定需求的范围，也就是要确定我们要做什么，不要做什么。这个过程往往需要和不同的人进行沟通，比如和产品经理、项目经理、UI 设计师、运营人员等进行沟通，确定我们要做什么，不要做什么。而且这个需求还和可能方案有关，涉及到我们如何设计这个可视化的配置。

那么经过和运营人员的交流，我们了解到运营人员的想法是，他希望有一个可视化的界面，可以通过拖拽的方式来配置布局，而且他希望所见即所得。一般来说他希望能使用类似盖楼的方式来配置布局，比如，第一层是轮播图，第二层是一张图片，第三层是两个商品等等。

这个想法你仔细思考的话，其实包含了很多待进一步确定的细节，比如：

- 盖楼的话需要如何界定一层？
- 一层里面可以放什么？
- 一层看成一个组件还是多个组件？
- 如果一层是一个组件，那么这个组件需要有哪些可配置属性？
- 如果一层是多个组件，那么这些组件之间的关系是什么？
- 一层里面的组件如何排序？
- 需要支持哪些组件？
- 这些组件最终要绑定具体的数据，那么数据是从哪里来的？比如轮播图的图片以及点上去的跳转链接是从哪里来的？
- 是否需要对整个布局进行某些参数的配置？

这些细节都需要进一步确定，然后再进行需求分解。

这一步的细节沟通你要拉上 UI 设计师，产品经理，运营人员等人，因为这些细节涉及到我们的技术选型，也涉及到我们的设计，所以需要和他们进行沟通。

在梳理需求的时候，这种沟通会非常频繁，所以你要有耐心，不要急于动手，因为这一步的沟通是非常重要的，如果这一步做不好，后面的开发就会非常困难。

这时候，为了大家能在同一理解上继续讨论，我们需要定义对于页面布局颗粒度的划分，比如：

- 布局：一个布局就是一个页面，比如首页、商品详情页等等
- 区块：一个区块就是一个矩形区域，比如轮播图、一张图片、两个商品等等
- 组件：我们定义除了区块边距之外的所有元素都是组件，比如轮播图里面的图片、商品的图片、商品的标题等等。

注意，颗粒度的划分对于实现的难度是有很大影响的，比如我们把区块和组件划分的更细，那么实现起来就会更加复杂；但是如果划分的太粗，那么我们的可视化配置就会变得非常简单，但是灵活性就会变差。

很多开发出身的同学会有一种冲动，就是想把所有的细节都考虑到，但是这样做是不对的，因为这样做会导致我们的设计变得非常复杂。比如有的同学可能会想，那不如我们直接做到基础组件这一级别，比如图片，文字，按钮，图标等等，但这样的话，我们的设计就会变得非常复杂，而且我们的可视化配置也会变得非常复杂，因为我们需要支持所有的基础组件，而且还需要支持这些组件的所有属性。从而导致的一个结果是运营人员无法使用我们的可视化配置，因为他们不会编程，而且他们也不会去学习我们的配置项目。

控制需求的范围是非常重要的，我们要做的是一个可视化的配置，而不是一个类似网页编辑器之类的东西。做满足需求的最小可行方案，而不是做满足需求的最大可行方案。这是需要大家在做需求分析时牢记的原则。

为了说清楚布局和区块的概念，我们先来看一下一个布局的示意图：

![页面布局示意图](http://ngassets.twigcodes.com/2c5de9de05e5be44056274bcf2a87d480ed9f5f7ddc9c8318efc9a3a46d391fa.png)

需要指出的是，这里面的区块和组件是有区别的，区块是一个矩形区域，而组件是一个个的元素，比如轮播图里面的图片、商品的图片、商品的标题等等。这里面的区块和组件是有区别的，区块是一个矩形区域，而组件是不含这个边距的元素，比如轮播图里面的图片、商品的图片、商品的标题等等。

你会观察到我们既有页面级别的边距，也有区块级别的边距，这个点是可以讨论的，你可以根据实际情况来决定。如果去掉页面级别的边距，那么在布局的时候，你就需要考虑到区块到页面的边距。如果页面级别和区块级别的边距都去掉的话，也可以，但代价是你需要在组件级别去保证这些边距。

在我们的课程中，其实我们只是给大家一个例子来说明如何配置布局，这个地方后面我们会以 `json` 的形式来配置布局，所以你可以改造成自己实际运营中需要配置的属性。

总之，布局的颗粒度划分和对应的配置项其实是一个非常复杂的问题，这个问题你可以在实际的项目中去思考，这里我们只是给大家一个例子来说明如何配置布局。但是这个约定必须要有，才能让我们后面的讨论更加顺畅。

有了这样的概念之后，我们进一步讨论了。页面级别和区块级别的配置是不一样的，比如页面级别的配置就是例如整个页面的背景色，内边距等等，而区块级别的配置就是 `Page Block` 中的配置，比如内边距，边框颜色等等。

- 需求 1：运营人员可以通过可视化的界面来配置首页的布局
  - 需求 1.1: 页面布局是由一个个区块组成的
    - 需求 1.1.1: 区块的定义就是一个包括内边距的矩形区域
    - 需求 1.1.2: 区块种类分为：图片行，轮播图，商品行，以及商品瀑布流
    - 需求 1.1.3: 图片行可以放一张图片，也可以放多张图片
      - 需求 1.1.3.1: 图片行中的图片是可以配置图片的链接以及点击跳转的链接
      - 需求 1.1.3.2: 一张图片时，图片按 `区块的宽度 - 2*内边距` 等比例缩放
      - 需求 1.1.3.3: 多于 3 张图片时，会形成可横向滑动的列表效果，但区别于小于等于 3 张图片的效果，需要显示第 4 张图片的 30%，以示还有更多图片。
      - 需求 1.1.3.4: 2-3 张图片时，会形成等宽的效果，也就是说，图片按 `区块的宽度 - 2*内边距 - 间距` 等比例缩放
    - 需求 1.1.4: 轮播图可以多张图片，每张图片可以配置图片的链接以及点击跳转的链接
    - 需求 1.1.5: 商品行可以放 1-2 个商品，注意这个需求也是一个假定的数量，每个公司根据运营需要不一定和我们课程一样的。单个商品的卡片样式和 2 个商品的卡片样式都由 UI 设计师提供。不提供配置卡片内的样式的能力。
    - 需求 1.1.6: 商品瀑布流比较特殊，它不是一个固定高度的区块，而是需要配置商品的类目，这个区块可以支持上拉加载更多的功能，也就是说，当用户滑动到这个区块的底部时，会自动加载下一页的商品。所以它的高度是不固定的。另外由于这个组件的特殊性，只能位于页面的最后一个区块，而且只能有一个。每个商品的卡片样式和一行 2 个商品的卡片样式一致。不提供配置卡片内的样式的能力。
  - 需求 1.2：运营人员不能接受太繁琐的配置步骤，比如太多的参数需要配置，太多的步骤需要操作。
    - 需求 1.2.1：运营人员可以通过拖拽的方式来调整顺序
    - 需求 1.2.2：运营人员可以通过点击的方式来配置区块的宽度，区块的内边距，区块背景色，边框颜色，边框宽度等等。
    - 需求 1.2.3：运营人员可以通过点击的方式来配置区块的数据，根据区块的类型，运营人员可以配置不同的数据
      - 需求 1.2.3.1：图片行的数据可以配置图片的链接以及点击跳转的链接
      - 需求 1.2.3.2：轮播图的数据可以配置图片的链接以及点击跳转的链接
      - 需求 1.2.3.3：商品行的数据可以配置商品，需要提供某种方式来搜索商品，比如输入商品名称，然后搜索出商品列表，然后运营人员可以选择商品
      - 需求 1.2.3.4：商品瀑布流的数据可以配置商品的类目 ID
- 需求 2：首页的布局是有生效时间段的，比如 2020-01-01 00:00:00 到 2020-01-02 00:00:00
- 需求 3：首页的布局可以有多个，因为不同的时间段，首页的布局可能是不一样的
  - 需求 3.1：布局保存时，不会立即生效，而是需要运营人员手动发布布局，才会生效
  - 需求 3.2：布局保存时，不保存生效时间段，而是保存布局的状态，比如草稿、已发布、已下线
- 需求 4：首页的布局可以有几个状态，比如草稿、已发布、已下线
  - 需求 4.1：草稿状态的布局和已下线状态的布局，只有运营人员可以看到，App 是看不到的
  - 需求 4.2：已发布状态的布局，运营人员和 App 都可以看到
  - 需求 4.3：运营人员可以发布布局，在发布时，需要选择布局的生效时间段，后端会校验时间段是否有重叠，如果有重叠，那么会提示运营人员，需要重新选择时间段
  - 需求 4.4：运营人员可以下线布局，下线布局后，App 就看不到这个布局了
- 需求 5：相同或者重叠的时间段，只能有一个布局是已发布的，因为 App 只能展示一个布局
- 需求 6：App 获取的布局是当前时间段的已发布的布局，如果当前时间段没有布局，那么 App 获取的是最近的一个布局
  - 需要思考的是，如果当前时间段没有布局，那么 App 获取的是最近的一个布局，那么这个最近的布局是什么？是最近的已发布的布局，还是最近的任意布局？如果还是没有布局，那么 App 获取的是什么？也就是如何兜底？这其实是一个隐含的需求，需要我们思考。
- 需求 7：运营人员可以创建/编辑/删除布局
- 需求 8：运营人员可以按条件查询布局，查询条件包括
  - 需求 8.1：布局名称含有输入字符
  - 需求 8.2：选择布局状态：草稿、已发布、已下线
  - 需求 8.3：选择布局生效起始时间段，比如查询所有生效起始时间在从 2020-01-01 00:00:00 到 2020-01-02 00:00:00 之间的布局
  - 需求 8.4：选择布局生效结束时间段，比如查询所有生效结束时间在从 2020-01-01 00:00:00 到 2020-01-02 00:00:00 之间的布局
  - 需求 8.5：选择平台 App / Web ，默认是 App，其中 web 做为扩展需求
  - 需求 8.6：选择布局的目标对象，比如 Home / Category / About 等等，这个是扩展需求
- 需求 9：运营人员可以发布/下线布局
- 需求 10：app 得到的布局是当前时间在该布局的生效时间段内，且该布局处于发布状态，且目标平台为 `App`，且页面类型为首页。

事实上，我们可以进一步把需求分类，整理为表格，如下：

| 需求编号 | 需求描述 | 需求分类 |
| :------- | :------- | :------- |

## 1.5 技术选型

本课程的技术选型如下：

- 前端：Flutter
- 后端：Java
- 数据库：H2，MySQL
- 运维：Docker

前端采用 Flutter 的原因是我们的课程中既有 App 也有 Web 页面，而 Flutter 可以同时开发 App 和 Web 页面，这样大家可以使用同一种技术栈开发 App 和 Web，所以我们选择 Flutter 作为前端技术栈。

后端采用 Java 的原因是 Java 是一种非常成熟的语言，而且 Java 有非常成熟的生态，比如 Spring Boot、Spring Data JPA 等，这些都是非常成熟的框架，可以让我们快速地开发出高质量的产品。而且 Java 有非常成熟的开发工具，比如 IntelliJ IDEA、Eclipse 等，这些都是非常成熟的开发工具，可以让我们快速地开发出高质量的产品。

数据库采用 H2 和 MySQL 的原因是 H2 是一个内存数据库，而且可以模拟多种主流大型数据的方言，非常适合在开发阶段使用。而 MySQL 是一个关系型数据库，是目前在国内以及在开源社区普遍使用的数据库，所以我们选择 H2 和 MySQL 作为数据库技术栈。

运维采用 Docker 的原因是 Docker 是一个开源的应用容器引擎，可以让我们快速地部署和运行应用。而且 Docker 有非常成熟的生态和开发工具。

## 1.6 Flutter 简介

Flutter 是 Google 开源的移动 UI 框架，可以快速在 iOS 和 Android 上构建高质量的原生用户界面。Flutter 可以与现有的代码一起工作。在全世界，Flutter 正在被越来越多的开发者和组织使用，并且 Flutter 是完全免费、开源的。

fllutter 的特性如下：

- 快速开发
- 热重载
- 响应式 UI
- 跨平台
- 原生性能
- 富有表现力和灵活的 UI

## 1.7 Spring Boot 简介

Spring Boot 是一个基于 Spring 框架的快速开发脚手架，它可以简化 Spring 应用的开发和部署。Spring Boot 为所有 Spring 开发者提供了一个快速入门的方式，可以使用最少的代码创建一个独立的、产品级别的 Spring 应用。

Spring Boot 的主要目标是：

- 为所有 Spring 开发者提供一个快速入门的方式。
- 开箱即用，提供各种默认配置来简化项目配置。
- 减少配置代码。
- 无需 XML 配置。

Spring Boot 有以下特点：

- 创建独立的 Spring 应用。
- 嵌入式的 Servlet 容器，无需部署 WAR 文件。
- starters（启动器）简化 Maven/Gradle 配置。
- 自动配置 Spring。
- 提供生产就绪型功能，如指标、健康检查和外部化配置。

可以把 Spring Boot 看作一个胶水，它把各种 Spring 项目都粘在了一起。Spring Boot 使得开发 Spring 应用变得更加简单。

很多 Spring 周边的项目都提供了 Spring Boot 的支持，例如 Spring Data、Spring Security、Spring Session、Spring Cloud 等等。

在 Java 社区里面，Spring Boot 是非常流行的一个项目，它已经成为了 Java 开发者的首选框架以及事实上的标准。

### 1.7.1 Spring Boot 3.x

Spring Boot 3.x 是 Spring Boot 2.x 的下一个大版本，它要求的 JDK 版本是 JDK 17，而不是 JDK 8/11。从某种角度上说，Spring Boot 3.x 会带动整个 Java 生态系统的升级。与 Spring Boot 3.x 配合的 Spring Framework 也已经发布了 6.x 版本，它要求的 JDK 版本也是 JDK 17。

Spring Boot 3.x 的主要特性包括：

- 支持 JAVA 17。

  - Record 类型： Record 类型是 Java 16 引入的新特性，它可以用来定义一个不可变的数据类型，它的属性是 final 的，它的方法是隐式的，它的 equals() 和 hashCode() 方法也是隐式的。

  ```java
  public record Person(String name, int age) {}
  ```

  - Text Blocks：Text Blocks 是 Java 15 引入的新特性，它可以用来定义多行字符串。

  ```java
  String textBlock = """
      Hello,
      World
      """;
  ```

  - Switch 表达式：Switch 表达式是 Java 14 引入的新特性，它可以用来替代 switch 语句。

  ```java
  DayOfWeek day = DayOfWeek.FRIDAY;
  int numOfLetters = switch (day) {
      case MONDAY, FRIDAY, SUNDAY -> 6;
      case TUESDAY                -> 7;
      case THURSDAY, SATURDAY     -> 8;
      case WEDNESDAY              -> 9;
  };
  ```

  - Pattern Matching for instanceof：Pattern Matching for instanceof 是 Java 14 引入的新特性，它可以用来替代 instanceof 运算符。

  ```java
  Object obj = "Hello";
  if (obj instanceof String s) {
      System.out.println(s);
  }
  // 我们也可以在 switch-case 语句中使用它：
  switch (obj) {
      case String s -> System.out.println(s);
      case Integer i -> System.out.println(i);
      default -> System.out.println("Unknown type");
  }
  ```

  - Sealed Classes：Sealed Classes 是 Java 15 引入的新特性，它可以用来限制类的继承。

  ```java
  public sealed class Shape permits Circle, Rectangle, Square {}
  public final class Circle extends Shape {}
  public final class Rectangle extends Shape {}
  public final class Square extends Shape {}
  ```

  - Jakarta EE 9：最重要的变化可能是从 Java EE 跳转到 Jakarta EE9，其中包命名空间从 javax._ 更改为 jakarta._。因此，每当我们直接使用 Java EE 中的类时，我们都需要调整代码中的所有导入。

  - Spring Web MVC 的改进：最重要的一个改进是支持 RFC 7807，它是一个标准，它定义了一种标准的方式来表示错误和异常。

## 1.8 容器（Docker）

课程中采用容器作为开发和部署的方式，这样可以避免开发环境和生产环境的差异，从而提高开发效率。

### 1.8.1 Docker 简介

Docker 是一个开源的应用容器引擎，它可以让开发者打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 或 Windows 服务器上，也可以实现虚拟化。

Docker 的主要特性包括：

- 应用程序打包：Docker 可以将应用程序及其依赖项打包到一个可移植的容器中，这样就可以在任何地方运行它。
- 轻量级和可移植：Docker 容器比虚拟机更轻量级，因为容器不需要额外的操作系统，它们直接运行在宿主机的内核上。
- 可扩展性：Docker 可以很容易地扩展到多台服务器上，它提供了分布式应用程序的完美解决方案。
- 开源：Docker 是一个开源项目，它的源代码托管在 GitHub 上。

### 1.8.2 Docker 架构

Docker 客户端（Docker CLI）：Docker 客户端是 Docker 的主要用户界面，它允许用户在 Docker 主机上执行 Docker 命令。

Docker 镜像（Image）：Docker 镜像是一个只读的模板，它包含了运行一个应用程序所需的所有内容，包括代码、运行时、系统工具、系统库和设置。镜像可以用来创建 Docker 容器。

Docker 容器（Container）：Docker 容器是一个运行时的实例，它是从镜像创建的。容器可以被启动、启动、暂停、恢复、停止或删除。每个容器都是相互隔离的，它们有自己的文件系统、内存空间、进程空间和网络空间。

Docker 注册表（Registry）：Docker 注册表是一个存储和分发镜像的场所。Docker Hub 是 Docker 官方提供的一个公共注册表，它提供了丰富的镜像，可以用来创建 Docker 容器。

Docker Hub：Docker Hub 是一个公共的镜像仓库，它提供了丰富的镜像，可以用来创建 Docker 容器。

### 1.8.3 Docker 安装

Docker 的安装非常简单，我们只需要在 Linux 上运行以下命令即可：

```bash
$ curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun
```

在 Windows/Mac 上安装 Docker，我们可以直接下载安装包进行安装。下载地址：https://www.docker.com/products/docker-desktop
